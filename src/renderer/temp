vk::MemoryRequirements inBufferMemoryRequirements = renderer->mainDevices.device.getBufferMemoryRequirements(inBuffer);
	vk::MemoryRequirements outBufferMemoryRequirements = renderer->mainDevices.device.getBufferMemoryRequirements(outBuffer);
	vk::MemoryRequirements vertexBufferMemoryRequirements = renderer->mainDevices.device.getBufferMemoryRequirements(vertexBuffer);

	vk::PhysicalDeviceMemoryProperties memoryProperties = renderer->mainDevices.physicalDevice.getMemoryProperties();

	uint32_t memoryTypeIndex = uint32_t(~0);
	vk::DeviceSize memoryHeapSize = uint32_t(~0);

	for (uint32_t currentMemoryTypeIndex = 0; currentMemoryTypeIndex < memoryProperties.memoryTypeCount; ++currentMemoryTypeIndex) {
		vk::MemoryType memoryType = memoryProperties.memoryTypes[currentMemoryTypeIndex];
		if ((vk::MemoryPropertyFlagBits::eHostVisible & memoryType.propertyFlags) && (vk::MemoryPropertyFlagBits::eHostCoherent & memoryType.propertyFlags)) {
			memoryHeapSize = memoryProperties.memoryHeaps[memoryType.heapIndex].size;
			memoryTypeIndex = currentMemoryTypeIndex;
			break;
		}
	}

	vk::MemoryAllocateInfo inBufferMemoryAllocateInfo(inBufferMemoryRequirements.size, memoryTypeIndex);
	vk::MemoryAllocateInfo outBufferMemoryAllocateInfo(outBufferMemoryRequirements.size, memoryTypeIndex);
	vk::MemoryAllocateInfo vertexBufferMemoryAllocateInfo(outBufferMemoryRequirements.size, memoryTypeIndex);

	inBufferMemory = renderer->mainDevices.device.allocateMemory(inBufferMemoryAllocateInfo);
	outBufferMemory = renderer->mainDevices.device.allocateMemory(outBufferMemoryAllocataInfo);
	vertexBufferMemory = renderer->mainDevices.device.allocateMemory(vertexBufferMemoryAllocataInfo);
}

void Simulation::bindBuffers()
{
	renderer->mainDevices.device.bindBufferMemory(inBuffer, inBufferMemory, 0);
	renderer->mainDevices.device.bindBufferMemory(outBuffer, outBufferMemory, 0);
	renderer->mainDevices.device.bindBufferMemory(vertexBuffer, vertexBufferMemory, 0);
}

void Simulation::populateInBuffer()
{

	inBufferPtr = static_cast<float*>(renderer->mainDevices.device.mapMemory(inBufferMemory, 0,bufferSize));

	memcpy(inBufferPtr, vertices.data(), bufferSize);
	renderer->mainDevices.device.unmapMemory(inBufferMemory);


	vertexBufferPtr = static_cast<float*>(renderer->mainDevices.device.mapMemory(vertexBufferMemory, 0, bufferSize));
	memcpy(vertexBufferPtr, inBufferPtr, bufferSize);
	renderer->mainDevices.device.unmapMemory(vertexBufferMemory);

}

vk::DescriptorBufferInfo Simulation::getDescriptorBufferInfo(vk::Buffer buffer)
{
	vk::DescriptorBufferInfo bufferInfo(buffer, 0, numElements * sizeof(Vertex));
	return bufferInfo;
}

void Simulation::updateBuffers()
{
	inBufferPtr = static_cast<float*>(renderer->mainDevices.device.mapMemory(inBufferMemory, 0, bufferSize));
	outBufferPtr = static_cast<float*>(renderer->mainDevices.device.mapMemory(outBufferMemory, 0, bufferSize));
	vertexBufferPtr = static_cast<float*>(renderer->mainDevices.device.mapMemory(vertexBufferMemory, 0, bufferSize));

	memcpy(inBufferPtr, outBufferPtr, bufferSize);
	memcpy(vertexBufferPtr, inBufferPtr, bufferSize);

	renderer->mainDevices.device.unmapMemory(inBufferMemory);
	renderer->mainDevices.device.unmapMemory(outBufferMemory);
	renderer->mainDevices.device.unmapMemory(vertexBufferMemory);
}